<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>02.let和const</title>
    <style>
        *{
            padding: 0;
            margin: 0;
        }
        html,body{
            height: 100%;
        }
        .main{
            height: 100%;
            background: #eee
        }
        .note{
            float: left;
            width: 400px;
            height: 100%;
            overflow-y: auto;
            list-style: none;
            background-color: teal;
            padding: 20px 0
        }
        li{
            font-size: 14px;
            padding: 10px 10px;
            color:#fff
        }
        .demo{
            background-color: pink
        }
    </style>
</head>
<body>
    <div class="main">
        <ul class="note">
           <li>let命令：let声明的变量只在代码块{}内有效</li>
           <li>let不存在变量提升。let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</li>
           <li>暂时性死区:ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</li>
           <li>let不允许在相同作用域内，重复声明同一个变量。</li>
           <li><mark>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</mark></li>
           <li>const声明一个只读的常量。一旦声明，常量的值就不能改变。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li>\
           <li>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</li>
           <li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</li>
           <li>const声明的常量，也与let一样不可重复声明。</li>
           <li><mark>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</mark></li>
           <li>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</li>
        </ul>
        <div class="demo">
            <p class="demo1">
                    let a = 1;
                    // {
                    //     let b = 2;
                    // }
                    if(true){
                        let c =3;
                    }
                    console.log(a);
                    //console.log(b);//b is not defined
                    console.log(c);//c is not defined
            </p>
            <p class="demo2">
                    var a = 1;
                    // 如果在 Node 的 REPL 环境，可以写成 global.a
                    // 或者采用通用方法，写成 this.a
                    window.a // 1
                    
                    let b = 1;
                    window.b // undefined
            </p>
        </div>
    </div>
</body>
<!-- <script id="demojs">
for(var i = 0;i<5;i++){
    setTimeout(function(){
        console.log(i);//5,5,5,5,5
    },0)
} 
for(var i = 0;i<5;i++){
    (function(e){
        setTimeout(function(){
        console.log(e);//0,1,2,3,4 使用自执行函数获取i
    },0)
    })(i)
    
}
for(let i = 0;i<5;i++){
    setTimeout(function(){
        console.log(i);//0,1,2,3,4 let命令只在的所在代码块内｛｝有效
    },0)
}       
</script> -->
<script>

var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
     tmp = 'hello world';
  }
}

f();
   
</script>
</html>