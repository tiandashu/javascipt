<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <canvas></canvas>
</body>
<script></script>
<script>
    var canvas = document.querySelector('canvas');
    var ctx = canvas.getContext('2d');

    var vw = window.innerWidth;
    var vh = window.innerHeight;
    var allParticle = [];
    var bgcolor = ['red','green','pink','orange','yellow','teal','tan'];
    /*初始化canvas*/
    function Cinit() {
        canvas.width = vw;
        canvas.height = vh;
        render();
    }
    Cinit();
    
    /* 创建粒子的构造函数
    *  粒子的基础特性：大小、颜色、位置（鼠标的位置）
    *  粒子的运动特性：运动轨迹大小（范围）=》位置角度、位置范围
    *  粒子状态的变更：update
    *
    *
    * */

    function Particle() {
        //一般不要给构造函数中添加太多的属性，实例会单独复制一份，造成内存的浪费
    }
    //Particle的原型上创建可继承的属性
    Particle.prototype = {
        /*粒子的初始化参数 接受参数opt*/
        init:function (opt) {
            this.x = opt.x;
            this.y = opt.y;
            this.radius = opt.radius || 10;//粒子的大小
            this.bgColor = opt.bgColor || ['teal','yellow'];//颜色
            /* 粒子的运动特性：粒子在一定的轨道半径内出现在随机的位置(粒子的轨迹是一个圆)
            *  pathwayRadius 轨道半径 需要产生x、y轴上的正负值     也可将轨道半径设成动态的
            *  使用sin cos 函数
            * */
            this.angle = 0 + Math.random()*(Math.PI*2-0);
            this.pathwayRadius = opt.pathwayRadius || 10;
            this.pathwayX = this.pathwayRadius*Math.sin(this.angle);
            this.pathwayY = this.pathwayRadius*Math.cos(this.angle);
        },
        /*粒子的状态更新*/
        update:function () {
            this.x += this.pathwayX;
            this.y += this.pathwayY;
            /*让粒子的轨道每次增加一点点*/
            this.pathwayX += this.pathwayX*0.1;
            this.pathwayY += this.pathwayY*0.1;
            /*设置摩擦系数 0.9>0.9*0.9*/
            this.pathwayX *= 0.9;
            this.pathwayY *= 0.9;
            this.radius *= 0.9;
        },
        /*粒子的绘制*/
        draw:function (ctx) {
            ctx.beginPath();
            ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
            ctx.fillStyle = this.bgColor[parseInt(this.bgColor.length*Math.random())];
            ctx.fill();
        }
    }


    /*粒子的实例*/
    canvas.onmousemove = function (e) {
        var e = e || window.event;
        var x = e.pageX;
        var y = e.pageY;
        var p = new Particle();
        p.init({
            x:x,
            y:y,
            bgColor:bgcolor
        })
        /*将产生的小球接受起来，为了性能最多产生800个*/
        allParticle.push(p);
        /*性能处理最多存在800个*/
        if (allParticle.length>= 800){
            allParticle.shift();
        }

    }

    function render() {
        ctx.clearRect(0,0,vw,vh);/*去掉这个也是个好特效*/
        /*将生成的小球绘制出来并更新*/
        for (var i = 0,len = allParticle.length;i<len;i++){
            allParticle[i].draw(ctx);
            allParticle[i].update();
        }
        requestAnimationFrame(render);
    }
</script>
</html>