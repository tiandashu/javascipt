<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    // 接口
    // 接口是面向对象javascript程序员工具箱中最有用的工具之一。接口提供了一种用以说明一个对象应该具有哪些方法的手段

    // 接口的利
    // 既定的接口具有自我描述性，并能促进代码的重用，接口还能有助于稳定不同的类之间的通信方式。
    
    // 接口的弊
    // JavaScript本身是弱类型的语言，而接口的使用一定程度上强化了类型的作用，降低了语言的灵活性。
    // JavaScript 并没有提供对接口的内置支持，存在一定的风险
    // JavaScript 实现接口会对性能带来一定的影响（归咎于额外的方法调用的开销）
    // 接口存在的最大的问题是无法强迫其它程序员遵守你定义的接口。在别的语言中接口是内置的并被编译器识别的
    
    // JavaScript中模仿接口的三种方法：1.注释描述法  2.属性检查法  3.鸭式辩型法
    // 1.注释描述法  用注释模仿接口是最简单的方式，但是效果最差。这种方式模仿了其它面向对象语言中的做法
    /*
        interface Composite {
            function add(child);
            function remove(child);
            function getChild(index);
        }

        interface FormItem {
            function save();
        }
    */

    var CompositeForm = function(id, methods, action){
        
    }
    // implement the Composite interface
    CompositeForm.prototype.add = function(){

    };
    CompositeForm.prototype.remove = function(){

    };
    CompositeForm.prototype.getChild = function(){

    };
    // implement the FormItem interface
    CompositeForm.prototype.save = function(){

    };
    // 总结：优点是容易实现，不需要额外的类和函数，提高代码的重用性。缺点是：不会对真正实现了的正确的方法进行检查，没有报错不利于测试和调试

    // 2. 属性检查模仿接口
    // 所有类都明确声明自己实现了哪些接口，那些想与这些类打交道的对象可以针对这么声明进行检查。那些接口自身仍然只是注释，但现在可以通过检查一个属性得知某个类自称实现了什么接口
    /*
        interface Composite {
            function add(child);
            function remove(child);
            function getChild(index);
        }

        interface FormItem {
            function save();
        }
    */ 
        
    var CompositeForm = function(id, method, action){
        this.implementsInterfaces = ['Composite','FormItem'];
    }   
</script>